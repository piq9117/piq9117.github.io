<!doctype html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="x-ua-compatible" content="ie=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <title>piq9117 - Front End - My checklist in learning front end frameworks</title>
        <link href="https://fonts.googleapis.com/css?family=Nanum+Gothic+Coding&display=swap" rel="stylesheet">
        <link href="https://fonts.googleapis.com/css?family=EB+Garamond&display=swap" rel="stylesheet">
        <link rel="stylesheet" href="../css/default.css" />
    </head>
    <body>
        <header>
            <div class="logo">
                <a href="../">piq9117</a>
            </div>
            <nav>
                <a href="../">home</a>
                <a href="../about.html">about</a>
                <a href="../contact.html">contact</a>
            </nav>
        </header>

        <main role="main">
            <h1>Front End - My checklist in learning front end frameworks</h1>
            <article>
    <section class="header">
        Posted on September 12, 2018
        
    </section>
    <section>
        <p>After being involved in developing a big SPA<sup>™</sup> I’ve developed a
“To-learn” checklist when it comes to component based front end
frameworks, which is pretty much all of them nowadays. So far this list has
helped me with <a href="https://reactjs.org/">react</a>, <a href="https://angular.io/">angular</a>, and <a href="https://vuejs.org/">vue</a>.</p>
<p>Here they are in order:</p>
<h2 id="directory-structure">Directory Structure</h2>
<p>So far this has been the most important for me. If I can organize and access
files easily through out the project it will make the whole development process
easier because trying to figure out relative paths can become an overhead when
dealing with thousands of files, at least for me.</p>
<p>Since Typescript doesn’t have a convenient module system out of the box. I need
the framework to be able to accommodate <a href="https://basarat.gitbooks.io/typescript/docs/tips/barrel.html">barrel</a> files. It has
happened before where some versions of angular was not too friendly with barrel
files but I think they’ve changed that because I’ve been using a lot of barrel
files in an angular project and it’s been working like a charm.</p>
<p>Typescript helps out a lot in this because in <code class="codeLine">tsconfig.json</code>, in the
<code class="codeLine">path</code> field I can set a path to a directory and I can access it
through out the project without knowing the relative path.</p>
<p>Here’s how it looks</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode json"><code class="sourceCode json"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="er">&quot;path&quot;:</span> <span class="fu">{</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>  <span class="dt">&quot;components&quot;</span><span class="fu">:</span> <span class="ot">[</span><span class="st">&quot;src/shared-components&quot;</span><span class="ot">]</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="fu">}</span></span></code></pre></div>
<p>After setting up the <code class="codeLine">path</code> field, I can access files in
<code class="codeLine">shared-compoents</code> anywhere in the project like</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> { AwesomeComponent } <span class="im">from</span> <span class="st">&quot;components&quot;</span><span class="op">;</span></span></code></pre></div>
<p>This comes really useful when you have a lot of modules accessing your local
shared components directory or any shared local directory for that matter.
I wouldn’t know how to do this in Javascript, I probably would need to publish
the library to <a href="https://www.npmjs.com/">npm</a>.</p>
<h2 id="parent-child-component-relationship">Parent-Child Component Relationship</h2>
<p>This is when the parent and child component communicates. This is another thing
that I find important because parent components need to pass information to
their child components, and child components need to send messages to their
respective parent component.</p>
<p>In <a href="https://reactjs.org/">react</a> and <a href="https://vuejs.org/">vue</a>, passing down information to a child component
is in the form of <code class="codeLine">props</code>/<code class="codeLine">@Props</code>. In angular it will be
through the <code class="codeLine">@Input</code> decorator. They’re pretty similiar when it
comes to passing down information but <a href="https://angular.io/">angular</a> is <em>a little bit
diffrent</em> when it comes to the child passing it’s information to the parent. In
<a href="https://reactjs.org/">react</a> and <a href="https://vuejs.org/">vue</a> you’d pass a function/method to the child. In
<a href="https://angular.io/">angular</a>, the child emits the event then it’s up to the parent which
method to asssign to capture that event.</p>
<p>Using parent-child component communication opens up to reusable components,
if your components only rely to <code class="codeLine">props</code>, <code class="codeLine">@Input</code>, or
<code class="codeLine">@Props</code> just like a function that only relies on it’s arguments
(see also <a href="https://wiki.haskell.org/Combinator">combinators</a>). You can reuse this component in every
parent component that supplies that <code class="codeLine">props</code>.</p>
<h2 id="life-cycle">Life Cycle</h2>
<p>There are steps on how a component is rendered in these frameworks/library. These
steps are important to know when I start fetching data, binding data,
re-rendering the component, and if there’s a behavior that needs to happen
when the component gets destroyed. These frameworks also offer more granular
life cycle hooks, these can be used if the common life cycle hooks can’t handle
the use-case.</p>
<h2 id="routing">Routing</h2>
<p>Almost every application will have different routes to seperate information, and
the framework routing mechanism can help make it easier. Basic routing nowadays
are pretty straightforward.</p>
<p>What I need to learn when it comes to routing are:</p>
<ul>
<li>Nested Routes</li>
<li>Lazy Routing</li>
<li>Nested Lazy Routing</li>
<li>Route guards</li>
</ul>
<p>A page can show different information, and sometimes I need to render some window
that can show more than one page of information inside the main page. This is
where Nested Routes comes into play.</p>
<p>With big applications, Lazy Routing helps in decreasing <a href="https://developers.google.com/web/tools/lighthouse/audits/time-to-interactive">Time to Interactive</a>
because the application will only load the ui components that are needed
at that moment of render, it doesn’t bring in the rest of the components.</p>
<p>Nested Lazy routes become useful when I have nested routes that I don’t want to
load if the user doesn’t interactive with them.</p>
<p>Route guards are useful when I want to restrict users to access certain sections
of the application depending on their roles/permissions. This comes really
useful when it comes to multi-tenant applications.</p>
<h2 id="transclusionmultitransclusion">Transclusion/Multitransclusion</h2>
<p>I think this term only gets used in <a href="https://angular.io/">Angular</a> from what I’ve seen so
far. This is component composition in react, and it’s called <a href="https://vuejs.org/v2/guide/components-slots.html">slots</a>
in vue. This is how it looks:</p>
<h4 id="react">react</h4>
<div class="sourceCode" id="cb3"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="op">&lt;</span>SplitPane right<span class="op">=</span>{ComponentOne} left<span class="op">=</span>{CompoentTwo} <span class="op">/&gt;</span></span></code></pre></div>
<h4 id="angular">angular</h4>
<div class="sourceCode" id="cb4"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="op">&lt;</span>split<span class="op">-</span>pane<span class="op">&gt;</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>  <span class="op">&lt;</span>component<span class="op">-</span>one right<span class="op">&gt;&lt;/</span>component<span class="op">-</span>one<span class="op">&gt;</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>  <span class="op">&lt;</span>component<span class="op">-</span>one left<span class="op">&gt;&lt;/</span>component<span class="op">-</span>one<span class="op">&gt;</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a><span class="op">&lt;/</span>split<span class="op">-</span>pane<span class="op">&gt;</span></span></code></pre></div>
<h4 id="vue">vue</h4>
<div class="sourceCode" id="cb5"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="op">&lt;</span>split<span class="op">-</span>pane<span class="op">&gt;</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>  <span class="op">&lt;</span>component<span class="op">-</span>one slot<span class="op">=</span><span class="st">&quot;right&quot;</span><span class="op">&gt;&lt;/</span>component<span class="op">-</span>one<span class="op">&gt;</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>  <span class="op">&lt;</span>component<span class="op">-</span>one slot<span class="op">=</span><span class="st">&quot;left&quot;</span><span class="op">&gt;&lt;/</span>component<span class="op">-</span>one<span class="op">&gt;</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a><span class="op">&lt;/</span>split<span class="op">-</span>pane<span class="op">&gt;</span></span></code></pre></div>
<p>It’s a way to compose components. This becomes really useful with reusable
components. When this is done right, building a complex component can feel like a
playing with legos.</p>
<h2 id="state-management">State Management</h2>
<p>With a rich application comes state and with state comes suffering. Especially
if it’s not properly managed. So far the redux implementations have helped me.
I’ve used <a href="https://redux.js.org/">redux</a> for react applications, <a href="https://github.com/ngrx/platform/blob/master/docs/store/README.md">ngrx</a> for angular, and
recently I’ve been learning how to use <a href="https://vuex.vuejs.org/">vuex</a> in a vue application. What
I’ve noticed so far is if there’s an atomic store that keeps track of the
state and it’s changes, a huge application is easier to manage. My biggest
complaint about redux is it’s boilerplate.</p>
<h2 id="forms">Forms</h2>
<p>Finally, Forms! From what I’ve seen, <code class="codeLine">forms</code> can be the most stateful
component when it comes to editing data because you have that intermediate state
that needs to be updated/edited then resubmitted somewhere, and that includes
form validation. So I think there’s a lot going on when it comes to forms. When
I get a handle of forms in frameworks/libraries I’ll be more comfortable using
it.</p>
<h1 id="final-thoughts">Final thoughts</h1>
<p>There’s definitely more to learn than this list but when I can check off all
these items I’ll be comfortable with the framework, and when I go into a
project I can hit the ground running.</p>
    </section>
</article>

        </main>

        <footer>
            Site proudly generated by
            <a href="http://jaspervdj.be/hakyll">Hakyll</a>
        </footer>
    </body>
</html>
